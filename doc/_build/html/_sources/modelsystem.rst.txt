Model System
############

In terms of second quantisation operators, a general Hamiltonian can be written as 

.. math::
        H = - \sum_{ij} t_{ij}\hat{c}^{\dagger}_{i}\hat{c}_{j} + \frac{1}{2} \sum_{ijkl}
        V_{ijkl}\hat{c}^{\dagger}_{i}\hat{c}^{\dagger}_{k}\hat{c}_{l}\hat{c}_{j}

where :math:`c_{i, \sigma}` is the destruction operator for an electron at site :math:`i`
and spin :math:`\sigma`, :math:`c^{\dagger}_{i, \sigma}` is the creation operator for an
electron at site :math:`i` and spin :math:`\sigma`.

Model Hamiltonians geared to simulate the key physics of notoriously complicated 
complete Hamiltonians of large-scale interacting systems.


 
Lattice
=======

Lattice is an periodic array of discrete points in space generated by a set of 
discrete translation operations described by:

.. math::
        \vec{R} = n_1\vec{a}_1 + n_2\vec{a}_2 + n_3\vec{a}_3

where :math:`n_i` are any integers and :math:`\vec{a}_i` are known as the primitive
vectors which lie in different directions and span the lattice. The discrete points
can be atoms, ions, electronic site, spin one-half site, spinless fermion site, etc.

Generaly speaking, to build a The :class:`.Lattice` object, we need first define a
:class:`.Cell` object. :class:`.Cell` has attribute of dimension and three primitive
vectors :math:`\vec{a}_1` :math:`\vec{a}_2` and :math:`\vec{a}_3`. To initialize a 
cell:

.. code-block:: python

        cell = Cell(1,[d,0.,0.],[0.,0.,0.],[0.,0.,0.])

Then we can add arbitrary sites to this cell by assign coordinate and label of the
site:

.. code-block:: python

        cell.add_site(LatticeSite([0.,0.,0.],'A'))  

Then we add bonds to this cell by assign the integer coordinate of first cell, index
of first site in first cell and the integer coordinate of second cell, index of the
second site in second cell: 

.. code-block:: python

        cell.add_bond(LatticeBond([0,0,0],0,[1,0,0],0))

Finally complete it by assign the cell and shpe to the lattice to :class:`.Lattice`:

.. code-block:: python

        lattice = Lattice(cell,[4,1,1])

It may not be immediately obvious what this code does. Fortunately, :class:`.Lattice` objects
have a convenient :meth:`.Lattice.plot()` method to easily visualize the constructed lattice.

Linear lattice
--------------

Starting from the basics, we'll build a simple linear lattice with only one site.

.. literalinclude:: ../data/examples/modelsystem/linear.py
        :lines: 1-20
        :caption: /data/examples/modelsystem/linear.py

Visualize the lattice by :meth:`.Lattice.plot()` method.

.. figure:: ./pictures/linear.png
        :scale: 100 %
        :align: center

Two sites linear lattice 
------------------------

The next example is also linear lattice but a slightly more complicated, the cell of the
lattice is consist of two different sites.

.. literalinclude:: ../data/examples/modelsystem/two_sites_linear.py
        :lines: 1-20
        :caption: /data/examples/modelsystem/two_sites_linear.py

Visualize the lattice by :meth:`.Lattice.plot()` method.

.. figure:: ./pictures/two_sites_linear.png
        :scale: 100 %
        :align: center

Square lattice
--------------

From 1D to 2D, the most basic example square lattice.

.. literalinclude:: ../data/examples/modelsystem/square.py
        :lines: 1-20
        :caption: /data/examples/modelsystem/square.py

Visualize the lattice by :meth:`.Lattice.plot()` method.

.. figure:: ./pictures/square.png
        :scale: 100 %
        :align: center

Graphene lattice
--------------

Graphene lattice is a more general example:

- It is two dimension.

- The cell of graphene contain two sites.

- The primitive vectors of the cell are non-orthogonal.

.. literalinclude:: ../data/examples/modelsystem/graphene.py
        :lines: 1-35
        :caption: /data/examples/modelsystem/graphene.py

Visualize the lattice by :meth:`.Lattice.plot()` method.

.. figure:: ./pictures/graphene.png
        :scale: 100 %
        :align: center

Cubic lattice
--------------

Final example is a 3d cubic lattice.

.. literalinclude:: ../data/examples/modelsystem/cubic.py
        :lines: 1-35
        :caption: /data/examples/modelsystem/cubic.py

Visualize the lattice by :meth:`.Lattice.plot()` method.

.. figure:: ./pictures/cubic.png
        :scale: 100 %
        :align: center



Model Hamiltonian
=================

Analogy to the construction of molecular Hamiltonian, model hamiltonian usually set up
in three steps. 

- First, construct a lattice. 

- Second, generate a basis set for the lattice.To simplifies the mathematics, In what
  follows we will assume that the basis set is orthonormal.

- Finally, compute all kinds of one body terms and two body terms with that basis
  to define a Hamiltonian.

With the definition of lattice and site object done, to construct a model Hamiltonian, we need:

- Initialize the model Hamiltonian by assign lattice and site

.. code-block:: python

        moha = ModelHamiltonian(lattice,site)

- Then add one and two body interaction terms

.. code-block:: python

        moha.add_operator(OneBodyTerm(['c_dag','c'],[0,0,0],0,[0,0,0],0,-1.0))

        moha.add_operator(TwoBodyTerm(['n','n'],[0,0,0],0,[0,0,0],0,2.0))

You can check the one body interaction matrix and two body interaction tensor by


.. code-block:: python

        moha.one_body_matrix

        moha.two_body_tensor


Fermion Model
-------------------

- Tight Binding Model

In solid-state physics, the tight-binding model (or TB model) is an approach to the calculation
of electronic band structure using an approximate set of wave functions based upon superposition
of wave functions for isolated atoms located at each atomic site.

The Hamiltonian is:

.. math::
    \hat{H} =-t\sum_{<i,j> \sigma}\hat{c}^{\dagger}_{i, \sigma}\hat{c}_{j, \sigma}
       -\mu\sum_{i\sigma}\hat{c}^{\dagger}_{i\sigma}\hat{c}_{i\sigma}

Often one considers models with only nearest neighbour terms, :math:`<ij>` indicates nearest 
neighbours. And one takes :math:`t_{ij}=t` if i and j are at nearest neighbour sites, and 
:math:`t_{ij}=0` otherwise, :math:`\mu` is the chemical potential.

To represent the Hamilontion in the matrix form, we ignore the spin of the Hamiltonian and transform
the Hamiltonion to

.. math::
    \hat{H} =-t\sum_{<i,j>}\hat{c}^{\dagger}_{i}\hat{c}_{j}
       -\mu\sum_{i}\hat{c}^{\dagger}_{i}\hat{c}_{i}

.. literalinclude:: ../data/examples/modelsystem/tight_binding.py
        :lines: 1-100
        :caption: /data/examples/modelsystem/tight_binding.py
        


- Hubbard Model

The Hubbard model is an approximate model used, especially in solid-state physics, to describle
the transition between conducting and insulating systems. The basic hubbard model have only two
Hamiltonian is the simplest model of interacting particles on a lattice and reads.

The Hamiltonian is:

.. math::
    \hat{H}=-t\sum_{<i,j> \sigma}\hat{c}^{\dagger}_{i, \sigma}\hat{c}_{j, \sigma} +
    U\sum_{i}\hat{n}_{i, \uparrow}\hat{n}_{i, \downarrow}

where the first term is a one-electron term and accounts for the nearest-neighbor hopping, while 
the second term is the repulsive on-site interaction. The t and U are user specified parameters
and σ is the electron spin.

To represent the Hamilontion in the matrix form, we ignore the spin of the Hamiltonian and transform
the Hamiltonion to

.. math::
    \hat{H}=-t\sum_{<i,j>}\hat{c}^{\dagger}_{i}\hat{c}_{j} +
    U\sum_{i}\hat{n}_{i}\hat{n}_{i}

.. literalinclude:: ../data/examples/modelsystem/hubbard.py
        :lines: 1-100
        :caption: /data/examples/modelsystem/hubbard.py


Spin Model
-----------

Quantum spins are a complex object to deal with in many-body physics, it's niether a canonical
fermions or bosons. However, we can perform the Jordan–Wigner transformation that maps spin 
operators onto fermionic creation and annihilation operators

where

.. math::
        S^{z}_j = c^{\dagger}_{j}c_{j}-\frac{1}{2}
.. math::
        S^{+}_j = c^{\dagger}_{j}e^{i\pi\sum_{l<j}n_{l}}
.. math::
        S^{-}_j = c_{j}e^{-i\pi\sum_{l<j}n_{l}}
  

- Ising Model

The Ising model is a mathematical model of ferromagnetism in statistical mechanics. The 
model consists of discrete variables that represent magnetic dipole moments of atomic
spins that can be in one of two states (+1 or −1), allowing each spin to interact
with its neighbors.

The Hamiltonian is:

.. math::
    H=\sum_{<i,j> \sigma}-JS^{z}_{i}S^{z}_{j}


After Jordan–Wigner transformation, it becomes:

.. math::
    H = J\sum_{i}n_{i} - J\sum_{i}n_{i+1}n_{i}


.. literalinclude:: ../data/examples/modelsystem/ising.py
        :lines: 1-40
        :caption: /data/examples/modelsystem/ising.py

- Heisenberg Model

The Heisenberg model is a statistical mechanical model used in the study of critical points
and phase transitions of magnetic systems, in which the spins of the magnetic systems are
treated quantum mechanically.

The Hamiltonian is:

.. math::
    H=J\sum_{<i,j>}\vec{S}_{i}\vec{S}_{j} = 
    J\sum_{<ij>}\left[S^{z}_{i}S^{z}_{j} +
    \frac{1}{2}\left(S^{+}_{i}S^{-}_{j}+S^{-}_{i}S^{+}_{j}\right)\right]

where

.. math::
        \hat{S}_{i}^{+} = \hat{S}_{i}^{x} + i\hat{S}_{i}^{y}

.. math::
        \hat{S}_{i}^{-} = \hat{S}_{i}^{x} - i\hat{S}_{i}^{y}

.. math::
        \hat{S}_{i}^{z} = \frac{1}{2}(\hat{S}_{i}^{+}\hat{S}_{i}^{-}-\hat{S}_{i}^{-}\hat{S}_{i}^{+})


To perform the Jordan-Wigner transformation

.. math::
    H=-\frac{J}{2}\sum_{i}\left(c^{\dagger}_{i+1}c_{i}+c^{\dagger}_{i}c_{i+1}\right)
    +J\sum_{i}n_{i} - J\sum_{i}n_{i+1}n_{i}

.. literalinclude:: ../data/examples/modelsystem/heisenberg.py
        :lines: 1-40
        :caption: /data/examples/modelsystem/heisenberg.py

- XXZ Model

The Hamiltonian is:

.. math::
    H=\sum_{<ij>}J_{z}S^{z}_{i}S^{z}_{j} +
    \frac{J}{2}\left(S^{+}_{i}S^{-}_{j}+S^{-}_{i}S^{+}_{j}\right)

To perform the Jordan-Wigner transformation

.. math::
    H=-\frac{J}{2}\sum_{i}\left(c^{\dagger}_{i+1}c_{i}+c^{\dagger}_{i}c_{i+1}\right)
    +J_{z}\sum_{i}n_{i} - J_{z}\sum_{i}n_{i+1}n_{i}

- XY Model

The Hamiltonian is:

.. math::
    H=\sum_{<ij>}\frac{J}{2}\left(S^{+}_{i}S^{-}_{j}+S^{-}_{i}S^{+}_{j}\right)

To perform the Jordan-Wigner transformation

.. math::
    H=-\frac{J}{2}\sum_{i}\left(c^{\dagger}_{i+1}c_{i}+c^{\dagger}_{i}c_{i+1}\right)


