Molecular System
################
To begin a calculation with MoHa, the first step is to build a Hamiltonian of a 
system, either molecular system or model system. In most cases, we need to build a molecular
system

In terms of second quantisation operators, a general Hamiltonian can be written
as 

.. math::
        H = - \sum_{ij} t_{ij}\hat{c}^{\dagger}_{i}\hat{c}_{j} + \frac{1}{2} \sum_{ijkl}
        V_{ijkl}\hat{c}^{\dagger}_{i}\hat{c}^{\dagger}_{k}\hat{c}_{l}\hat{c}_{j}

The construction of molecular Hamiltonian usually set up in three steps. 

- First, construct a molecular geometry. 
- Second, generate a Gaussian basis set for the molecular.
- Finally, compute all kinds of one body terms and two body terms with that basis
  to define a Hamiltonian.

 
Molecule
=========
Molecule is a system consist with nucleus and electrons. For quantum chemistry
calculation, we will always used the Born-Oppenheimer apporimation, which assumption
that the motion of atomic nuclei and electrons in a molecule can be separated

.. math::
        \Psi_{molecule} = \psi_{electronic} \otimes \psi_{nuclear}

The module ``molecule`` in MoHa actually only contains imformation of the
nuclear. It has three class:

- ``Element``
Represents an element from the periodic table. The following attributes are supported for all elements:

        number
             The atomic number.

        symbol
             A string with the symbol of the element.

        name
             The full element name.

        group
             The group of the element (not for actinides and lanthanides).

        period
             The row of the periodic system.

- ``Atom``
Represents an Atom. The following attributes are supported for all atoms:

        element
             A object of ``Element`` class.

        coordinate
             The coordinate of the atom object.

- ``Molecule`` 
Represents an Molecule. The following attributes are supported for all molecule
object:
    title
       type: string
       title of the system
    size
       type: intager
       number of atoms
    symmetry
       type: string
       point group of the molecule
    bond_length
        Calculate the interatomic distances using the expression:
            .. math::
                R_{ij}=\sqrt{(x_i-x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}
        where x, y, and z are Cartesian coordinates and i and j denote atomic indices.

    bond_angle
        Calculate all possible bond angles. For example, the angle, :math:`\phi_{ijk}`, between atoms i-j-k, where j is the central atom is given by:

            .. math::

                \cos {\phi_{ijk}} = {\bf \vec{e}_{ji} } \cdot {\bf \vec{e}_{jk}}

        where the :math:`\bf \vec{e}_{ij}` are unit vectors between the atoms, e.g.,

            .. math::
                e_{ij}^x = - \left(x_i - x_j \right)/R_{ij},\ \ \ \ \ 
                e_{ij}^y = - \left(y_i - y_j \right)/R_{ij},\ \ \ \ \ 
                e_{ij}^z = - \left(z_i - z_j \right)/R_{ij}

    out_of_plane_angle
        Calculate all possible out-of-plane angles. For example, the angle :math:`\theta_{ijkl}` for atom i out of the plane containing atoms j-k-l (with k as the central atom, connected to i) is given by:

            .. math::
                \sin {\theta_{ijkl}} =  \frac{{\bf \vec{e}_{kj} \times \vec{e}_{kl} }}{ \sin {\phi_{jkl}}} \cdot  {\bf \vec{e}_{ki} }

    dihedral_angle

        Calculate all possible torsional angles. For example, the torsional angle :math:`\tau_{ijkl}` for the atom connectivity i-j-k-l is given by:

            .. math::
                \cos {\tau_{ijkl}} = \frac{ ({\bf \vec{e}_{ij} \times \vec{e}_{jk} }) \cdot ( {\bf \vec{e}_{jk} \times \vec{e}_{kl} } ) }{  \sin {\phi_{ijk}} \  \ \sin{\phi_{jkl}}}



To be convenient, we can specify the molecular object by load the molecular geometry from file formats.

.. code-block:: python

    mol = IOSystem.from_file('h2o.xyz')

Basis Set
=========
MoHa supports basis sets consisting of generally contracted Cartesian Gaussian functions up to a maximum angular momentum of seven (I functions). HORTON is using the same basis set format as NWChem, and the basis sets can be downloaded from the EMSL webpage (https://bse.pnl.gov/bse/portal).

The basis object is a list of list with the follwing structure

.. math::

    [Idx x y z #CONTR CONTR Atomidx]

Idx is the AO index. Atomidx, is the index of the associated atom. #CONTR contains the number of primitive functions in the contracted.

CONTR contains all the information about the primitive functions and have the form:

.. math::

    [N ζ c l m n]

Inside the integral call, the basisset file is reconstructed into three different arrays, containing the basisset information. The first one is basisidx that have the following form:

.. math::

    [#primitives\ \ \ loopstartidx]

It thus contains the number of primitives in each basisfunction, and what start index it have for loop inside the integral code.

The second array is basisint, that have the following forms:

.. math::

    [l m n]
    [l m n atomidx]

The first one is for regular integrals and the second one is for derivatives. Both contains all the angular momentum quantum numbers, and the derivative also contains the atom index (used in derivative of VNe).

The last array is basisfloat and have the following forms:

.. math::
    [N ζ c x y z]
    [N ζ c x y z N_{x,+} N_{x,−} N_{y,+} N_{y,−} N_{z,+} N_{z,−}]

basisfloat contains the normalization constants, Gaussian exponent and prefacor and the coordinates of the atoms. The second one is again for the derivatives, it contains normalization constants of the differentiated primitives.

Hamilonian
==========

Molecular Integrals
===================
Contains the information about how the integrals are calculated. In the equations in this section the following definitions is used.

.. math::
    p=a+b
    μ=aba+b
    Px=aAx+bBxp
    XAB=Ax−Bx

Here a and b are Gaussian exponent factors. Ax and Bx are the position of the Gaussians in one dimension. Further the basisset functions is of Gaussian kind and given as:

.. math::
    ϕA(r)=N(x−Ax)l(y−Ay)m(z−Az)nexp(−ζ(r⃗ −A⃗ )2)

with a normalization constant given as:

.. math::
    N=(2απ)3/4[(8α)l+m+nl!m!n!(2l)!(2m)!(2n)!]

Boys Function
-------------
The Boys function is given as:
.. math::
    Fn(x)=∫10exp(−xt2)t2ndt

FUNCTION:

MIcython.boys(m,T)
return value
Input:

m, subscript of the Boys function
T, argument of the Boys function
Output:

value, value corrosponding to given m and T

Expansion coefficients
----------------------
The expansion coefficient is found by the following recurrence relation:

Ei,jt=0,t<0ort>i+j
Ei+1,jt=12pEi,jt−1+XPAEi,jt+(t+1)Ei,jt+1
Ei,j+1t=12pEi,jt−1+XPBEi,jt+(t+1)Ei,jt+1
With the boundary condition that:

E0,00=exp(−pX2AB)
FUNCTION:

MolecularIntegrals.E(i,j,t,Qx,a,b,XPA,XPB,XAB)
return val
Input:

i, input values
j, input values
t, input values
Qx, input values
a, input values
b, input values
XPA, input values
XPB, input values
XAB, input values
Output:

val, value corrosponding to the given input

Overlap
-------
The overlap integrals are solved by the following recurrence relation:

.. math::
    Si+1,j=XPASij+12p(iSi−1,j+jSi,j−1)
    Si,j+1=XPBSij+12p(iSi−1,j+jSi,j−1)

With the boundary condition that:

.. math::

    S00=πp‾‾√exp(−μX2AB)

FUNCTION:

MolecularIntegrals.Overlap(a, b, la, lb, Ax, Bx)
return Sij
Input:

a, Gaussian exponent factor
b, Gaussian exponent factor
la, angular momentum quantum number
lb, angular momentum quantum number
Ax, position along one axis
Bx, position along one axis
Output:

Sij, non-normalized overlap element in one dimension


Kinetic energy
--------------
The kinetic energy integrals are solved by the following recurrence relation:

.. math::

    Ti+1,j=XPATi,j+12p(iTi−1,j+jTi,j−1)+bp(2aSi+1,j−iSi−1,j)
    Ti,j+1=XPBTi,j+12p(iTi−1,j+jTi,j−1)+ap(2bSi,j+1−iSi,j−1)

With the boundary condition that:

.. math::
    T00=[a−2a2(X2PA+12p)]S00

FUNCTION:

Kin(a, b, Ax, Ay, Az, Bx, By, Bz, la, lb, ma, mb, na, nb, N1, N2, c1, c2)
return Tij, Sij
Input:

a, Gaussian exponent factor
b, Gaussian exponent factor
Ax, position along the x-axis
Bx, position along the x-axis
Ay, position along the y-axis
By, position along the y-axis
Az, position along the z-axis
Bz, position along the z-axis
la, angular momentum quantum number
lb, angular momentum quantum number
ma, angular momentum quantum number
mb, angular momentum quantum number
na, angular momentum quantum number
nb, angular momentum quantum number
N1, normalization constant
N2, normalization constant
c1, Gaussian prefactor
c2, Gaussian prefactor
Output:

Tij, normalized kinetic energy matrix element
Sij, normalized overlap matrix element


Electron-nuclear attraction
---------------------------

The electron-nuclear interaction integral is given as:

V000ijklmn=2πp∑ti+jEijt∑uk+lEklu∑vm+nEmnvRtuv
FUNCTION:

MolecularIntegrals.elnuc(P, p, l1, l2, m1, m2, n1, n2, N1, N2, c1, c2, Zc, Ex, Ey, Ez, R1)
return Vij
Input:

P, Gaussian product
p, exponent from Guassian product
l1, angular momentum quantum number
l2, angular momentum quantum number
m1, angular momentum quantum number
n1, angular momentum quantum number
n2, angular momentum quantum number
N1, normalization constant
N2, normalization constant
c1, Gaussian prefactor
c2, Gaussian prefactor
Zc, Nuclear charge
Ex, expansion coefficients
Ey, expansion coefficients
Ez, expansion coefficients
R1, hermite coulomb integrals
Output:

Vij, normalized electron-nuclei attraction matrix element

Electron-electron repulsion
---------------------------
The electron-electron repulsion integral is calculated as:

gabcd=∑tl1+l2Eabt∑um1+m2Eabu∑vn1+n2Eabv∑τl3+l4Ecdτ∑νm3+m4Ecdν∑ϕn3+n4Ecdϕ(−1)τ+ν+ϕ2π5/2pqp+q‾‾‾‾‾√Rt+τ,u+ν,v+ϕ(α,RPQ)
FUNCTION:

MIcython.elelrep(p, q, l1, l2, l3, l4, m1, m2, m3, m4, n1, n2, n3, n4, N1, N2, N3, N4, c1, c2, c3, c4, E1, E2, E3, E4, E5, E6, Rpre)
return Veeijkl
Input:

p, Gaussian exponent factor from Gaussian product
q, Gaussian exponent factor from Gaussian product
l1, angular momentum quantum number
l2, angular momentum quantum number
l3, angular momentum quantum number
l4, angular momentum quantum number
m1, angular momentum quantum number
m2, angular momentum quantum number
m3, angular momentum quantum number
m4, angular momentum quantum number
n1, angular momentum quantum number
n2, angular momentum quantum number
n3, angular momentum quantum number
n4, angular momentum quantum number
N1, normalization constant
N2, normalization constant
N3, normalization constant
N4, normalization constant
c1, Gaussian prefactor
c2, Gaussian prefactor
c3, Gaussian prefactor
c4, Gaussian prefactor
E1, expansion coefficient
E2, expansion coefficient
E3, expansion coefficient
E4, expansion coefficient
E5, expansion coefficient
E6, expansion coefficient
Rpre, hermite coulomb integral
Output:

Veeijkl, normalized electron-electron repulsion matrix element

Build Hamilton
==============
To build a Hamiltonian object, MoHa can load the molecular geometry and and basis from file
format.

.. code-block:: python

    mol,orbs = IOSystem.from_file('h2o.xyz','sto-3g.nwchem')
    ham = Hamiltonian.build(mol,orbs)
